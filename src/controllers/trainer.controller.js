const {trainerService} = require('../services');
const catchAsync = require('../utils/catchAsync');
const { status } = require('http-status');
const ApiError = require('../utils/ApiError');

const getTrainerMembers = catchAsync(async (req, res) => {
  const trainerId = req.user.id; 
  const members = await trainerService.getTrainerMembers(trainerId);
  
  res.status(200).json({ members });
});

const getPendingMemberRequests = catchAsync(async (req, res) => {
  const trainerId = req.user.roleId; 
  console.log("trainerId", trainerId);
  const requests = await trainerService.getPendingMemberRequests(trainerId);
  
  res.status(200).json({ requests });
});

const respondToMemberRequest = catchAsync(async (req, res) => {
  const trainerId = req.user.roleId;
  const { requestId } = req.params;
  const { action, alternativeTrainerId } = req.body; 

  if (!action) {
    throw new ApiError(status.BAD_REQUEST, 'Action is required');
  }

  const response = await trainerService.respondToMemberRequest(trainerId, requestId, action, alternativeTrainerId);

  res.status(200).json({
    message: `Request ${action} successfully`,
    request: response,
  });
});

const createWorkoutPlan = catchAsync(async (req, res) => {
  const trainerId = req.user.roleId;
  const { memberId } = req.params;
  const workoutData = req.body;

  const { workoutPlan, sessions } = await trainerService.createWorkoutPlan(trainerId, memberId, workoutData);

  res.status(201).json({
    message: 'Workout plan created successfully',
    workoutPlan,
    autoGeneratedSessions: sessions,
  });
});

const createSession = catchAsync(async (req, res) => {
  const trainerId = req.user.id;
  const { memberId } = req.params;
  const sessionData = req.body;

  const session = await trainerService.createSession(trainerId, memberId, sessionData);

  res.status(201).json({
    message: 'Session created successfully',
    session,
  });
});

const updateSession = catchAsync(async (req, res) => {
  const trainerId = req.user.roleId;
  const { sessionId } = req.params;
  const updateData = req.body;
  console.log("updateData", updateData," sessionId", sessionId, "  trainerId", trainerId);
  const updatedSession = await trainerService.updateSession(trainerId, sessionId, updateData);

  res.status(200).json({
    message: 'Session updated successfully',
    session: updatedSession,
  });
});

const deleteSession = async (trainerId, sessionId) => {
  const session = await TrainingSession.findById(sessionId);
  if (!session) {
    throw new ApiError(status.NOT_FOUND, 'Session not found');
  }
  if (session.trainerId.toString() !== trainerId.toString()) {
    throw new ApiError(status.FORBIDDEN, 'You are not authorized to delete this session');
  }

  await TrainingSession.findByIdAndDelete(sessionId);
  return { message: 'Session deleted successfully' };
};

const respondToSessionRequest = catchAsync(async (req, res) => {
  const trainerId = req.user.id;
  const { sessionId } = req.params;
  const { action } = req.body; // "approve" or "reject"

  if (!action) {
    throw new ApiError(status.BAD_REQUEST, 'Action is required');
  }

  const session = await trainerService.respondToSessionRequest(trainerId, sessionId, action);

  res.status(200).json({
    message: `Session ${action} successfully`,
    session,
  });
});

const getPendingSessionRequests = catchAsync(async (req, res) => {
  const trainerId = req.user.roleId;

  const requests = await trainerService.getPendingSessionRequests(trainerId);

  res.status(200).json({ requests });
});

const completeSession = catchAsync(async (req, res) => {
  const trainerId = req.user.id;
  const { sessionId } = req.params;
  const completionData = req.body;

  const completedSession = await trainerService.completeSession(trainerId, sessionId, completionData);

  res.status(200).json({
    message: 'Session marked as completed',
    session: completedSession,
  });
});

const cancelSession = catchAsync(async (req, res) => {
  const trainerId = req.user.roleId;
  const { sessionId } = req.params;

  const cancelledSession = await trainerService.cancelSession(trainerId, sessionId);

  res.status(200).json({
    message: 'Session cancelled successfully',
    session: cancelledSession,
  });
});

const getSessionsByStatus = catchAsync(async (req, res) => {
  const trainerId = req.user.id;
  const { status } = req.query;

  const sessions = await trainerService.getSessionsByStatus(trainerId, status);

  res.status(200).json({ sessions });
});

const getAllSessionsByTrainerId = catchAsync(async (req, res) => {
  const trainerId = req.user.roleId;

  const sessions = await trainerService.getAllsessions(trainerId);

  res.status(200).json({ sessions });
});

const getAvailableTimeSlotsForRange = catchAsync(async (req, res) => {
  const { trainerId } = req.params;
  const { startDate, endDate } = req.query;

  if (!startDate || !endDate) {
    throw new ApiError(status.BAD_REQUEST, 'Both startDate and endDate are required');
  }

  const start = new Date(startDate);
  const end = new Date(endDate);

  if (isNaN(start.getTime()) || isNaN(end.getTime()) || start > end) {
    throw new ApiError(status.BAD_REQUEST, 'Invalid date range');
  }

  const availability = await trainerService.getAvailableTimeSlotsForRange(trainerId, start, end);

  res.status(status.OK).json({
    trainerId,
    startDate,
    endDate,
    availability,
  });
});


const updateAvailability = catchAsync(async (req, res) => {
  const trainerId = req.user.roleId;
  const { availabilityByDate, availabilityRecurring } = req.body;

  if (!availabilityByDate || typeof availabilityByDate !== 'object') {
    throw new ApiError(status.BAD_REQUEST, 'availabilityByDate must be an object');
  }

  if (!availabilityRecurring || typeof availabilityRecurring !== 'object') {
    throw new ApiError(status.BAD_REQUEST, 'availabilityRecurring must be an object');
  }

  const updatedTrainer = await trainerService.updateAvailability(
    trainerId,
    availabilityByDate,
    availabilityRecurring
  );

  res.status(status.OK).json({
    message: 'Availability updated successfully',
    availabilityByDate: updatedTrainer.availabilityByDate,
    availabilityRecurring: updatedTrainer.availabilityRecurring,
  });
});



module.exports = {
  getTrainerMembers,
  getPendingMemberRequests,
  respondToMemberRequest,
  createWorkoutPlan,
  createSession,
  deleteSession,
  updateSession,
  respondToSessionRequest,
  getPendingSessionRequests,
  completeSession,
  cancelSession,
  getSessionsByStatus,
  getAvailableTimeSlotsForRange,
  updateAvailability,
  getAllSessionsByTrainerId
};
